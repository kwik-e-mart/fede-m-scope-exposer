#!/bin/bash

set -euo pipefail

is_httproute_empty() {
  local yaml_content="$1"

  local num_rules
  local backend_name
  local backend_weight

  num_rules=$(yq '.spec.rules | length' <<< "$yaml_content")
  backend_name=$(yq '.spec.rules[0].backendRefs[0].name' <<< "$yaml_content")
  backend_weight=$(yq '.spec.rules[0].backendRefs[0].weight' <<< "$yaml_content")

  # An HTTPRoute is "empty" if it only has one rule with response-404 backend and weight 0
  if [[ "$num_rules" -eq 1 && \
        "$backend_name" == "response-404" && \
        "$backend_weight" == "0" ]]; then
    echo "true"
  else
    echo "false"
  fi
}

create_http_rule() {
  local rule_path="$1"
  local service_json="$2"
  local blue_green_config="$3"

  local service_name
  local service_port

  service_name=$(echo "$service_json" | jq -r '.name')
  service_port=$(echo "$service_json" | jq -r '.port.number // .port.name // 80')

  # Check if there's blue/green configuration
  if [[ "$blue_green_config" != "null" && -n "$blue_green_config" ]]; then
    # Parse blue/green destinations and weights from the annotation
    local blue_weight green_weight blue_service green_service

    blue_weight=$(echo "$blue_green_config" | jq -r '.forward.targetGroups[0].weight // 100')
    green_weight=$(echo "$blue_green_config" | jq -r '.forward.targetGroups[1].weight // 0')
    blue_service=$(echo "$blue_green_config" | jq -r '.forward.targetGroups[0].serviceName')
    green_service=$(echo "$blue_green_config" | jq -r '.forward.targetGroups[1].serviceName')

    # Determine if we need URL rewrite (path is not / and not empty)
    local filters_json='[]'
    if [[ "$rule_path" != "/" && -n "$rule_path" ]]; then
      filters_json=$(jq -n \
        '[{
          "type": "URLRewrite",
          "urlRewrite": {
            "path": {
              "type": "ReplacePrefixMatch",
              "replacePrefixMatch": "/"
            }
          }
        }]')
    fi

    # Create rule with weighted backends
    jq -n \
      --arg path "$rule_path" \
      --arg blue_service "$blue_service" \
      --arg green_service "$green_service" \
      --arg service_port "$service_port" \
      --argjson blue_weight "$blue_weight" \
      --argjson green_weight "$green_weight" \
      --argjson filters "$filters_json" \
      '{
        matches: [
          {
            path: {
              type: "PathPrefix",
              value: $path
            }
          }
        ],
        filters: $filters,
        backendRefs: [
          {
            name: $blue_service,
            port: ($service_port | tonumber),
            weight: $blue_weight
          },
          {
            name: $green_service,
            port: ($service_port | tonumber),
            weight: $green_weight
          }
        ]
      }'
  else
    # Determine if we need URL rewrite
    local filters_json='[]'
    if [[ "$rule_path" != "/" && -n "$rule_path" ]]; then
      filters_json=$(jq -n \
        '[{
          "type": "URLRewrite",
          "urlRewrite": {
            "path": {
              "type": "ReplacePrefixMatch",
              "replacePrefixMatch": "/"
            }
          }
        }]')
    fi

    # Single destination without blue/green
    jq -n \
      --arg path "$rule_path" \
      --arg service_name "$service_name" \
      --arg service_port "$service_port" \
      --argjson filters "$filters_json" \
      '{
        matches: [
          {
            path: {
              type: "PathPrefix",
              value: $path
            }
          }
        ],
        filters: $filters,
        backendRefs: [
          {
            name: $service_name,
            port: ($service_port | tonumber)
          }
        ]
      }'
  fi
}

update_httproute_rule() {
  local hr_yaml="$1"
  local rule_path="$2"
  local service_json="$3"
  local blue_green_config="$4"

  local service_name
  local service_port
  local updated_hr

  service_name=$(echo "$service_json" | jq -r '.name')
  service_port=$(echo "$service_json" | jq -r '.port.number // .port.name // 80')

  # Determine if we need URL rewrite
  local filters_json='[]'
  if [[ "$rule_path" != "/" && -n "$rule_path" ]]; then
    filters_json=$(jq -n \
      '[{
        "type": "URLRewrite",
        "urlRewrite": {
          "path": {
            "type": "ReplacePrefixMatch",
            "replacePrefixMatch": "/"
          }
        }
      }]')
  fi

  # Update the first rule's path
  updated_hr=$(echo "$hr_yaml" | yq eval ".spec.rules[0].matches[0].path.value = \"$rule_path\"")

  # Update filters
  if [[ "$rule_path" != "/" && -n "$rule_path" ]]; then
    updated_hr=$(echo "$updated_hr" | yq eval ".spec.rules[0].filters = $filters_json")
  else
    updated_hr=$(echo "$updated_hr" | yq eval "del(.spec.rules[0].filters)")
  fi

  # Check if there's blue/green configuration
  if [[ "$blue_green_config" != "null" && -n "$blue_green_config" ]]; then
    # Parse blue/green destinations and weights
    local blue_weight green_weight blue_service green_service

    blue_weight=$(echo "$blue_green_config" | jq -r '.forward.targetGroups[0].weight // 100')
    green_weight=$(echo "$blue_green_config" | jq -r '.forward.targetGroups[1].weight // 0')
    blue_service=$(echo "$blue_green_config" | jq -r '.forward.targetGroups[0].serviceName')
    green_service=$(echo "$blue_green_config" | jq -r '.forward.targetGroups[1].serviceName')

    # Set blue backend
    updated_hr=$(echo "$updated_hr" | yq eval ".spec.rules[0].backendRefs[0].name = \"${blue_service}\"")
    updated_hr=$(echo "$updated_hr" | yq eval ".spec.rules[0].backendRefs[0].port = $service_port")
    updated_hr=$(echo "$updated_hr" | yq eval ".spec.rules[0].backendRefs[0].weight = $blue_weight")

    # Add green backend
    updated_hr=$(echo "$updated_hr" | yq eval ".spec.rules[0].backendRefs += [{\"name\": \"${green_service}\", \"port\": $service_port, \"weight\": $green_weight}]")
  else
    # Single destination
    updated_hr=$(echo "$updated_hr" | yq eval ".spec.rules[0].backendRefs[0].name = \"${service_name}\"")
    updated_hr=$(echo "$updated_hr" | yq eval ".spec.rules[0].backendRefs[0].port = $service_port")
    updated_hr=$(echo "$updated_hr" | yq eval "del(.spec.rules[0].backendRefs[0].weight)")
  fi

  echo "$updated_hr"
}

find_rule_index() {
  local hr_yaml="$1"
  local target_path="$2"

  local num_rules
  local i
  local current_path

  num_rules=$(yq '.spec.rules | length' <<< "$hr_yaml")

  for ((i=0; i<num_rules; i++)); do
    current_path=$(yq ".spec.rules[$i].matches[0].path.value" <<< "$hr_yaml")
    if [[ "$current_path" == "\"$target_path\"" || "$current_path" == "$target_path" ]]; then
      echo "$i"
      return
    fi
  done

  echo "-1"  # Not found
}

replace_existing_rule() {
  local hr_yaml="$1"
  local rule_path="$2"
  local service_json="$3"
  local blue_green_config="$4"
  local rule_index="$5"

  local updated_hr
  local new_rule

  # Create the new rule
  new_rule=$(create_http_rule "$rule_path" "$service_json" "$blue_green_config")

  # Replace the existing rule at the found index
  updated_hr=$(echo "$hr_yaml" | yq eval -o=json '.' | \
    jq --argjson newrule "$new_rule" ".spec.rules[$rule_index] = \$newrule" | \
    yq eval -P '.')

  echo "$updated_hr" | yq .
}

add_new_rule() {
  local hr_yaml="$1"
  local rule_path="$2"
  local service_json="$3"
  local blue_green_config="$4"

  local updated_hr
  local new_rule

  # Create the new http rule
  new_rule=$(create_http_rule "$rule_path" "$service_json" "$blue_green_config")

  # Add the new rule to the existing rules array
  updated_hr=$(echo "$hr_yaml" | yq eval ".spec.rules += [$new_rule]")

  echo "$updated_hr"
}

# Main script logic
echo "=== Starting build_ingress_with_rule for Istio HTTPRoute ==="
echo "K8S_NAMESPACE: $K8S_NAMESPACE"
echo "SERVICE_ID: $SERVICE_ID"
echo "SCOPE_ID: $SCOPE_ID"
echo "RULE_PATH: $RULE_PATH"

HTTPROUTE_NAME=$(kubectl get httproute -n "$K8S_NAMESPACE" -l "service_id=$SERVICE_ID" -o jsonpath="{.items[0].metadata.name}")
echo "Found HTTPRoute: $HTTPROUTE_NAME"

HTTPROUTE=$(kubectl get httproute -n "$K8S_NAMESPACE" "$HTTPROUTE_NAME" -o yaml)

# Extract blue/green annotation and service from SCOPE_RULE
echo ""
echo "=== SCOPE_RULE content ==="
echo "$SCOPE_RULE" | jq '.'

BLUE_GREEN_CONFIG=$(echo "$SCOPE_RULE" | jq -r '.blue_green_annotation // "null"')
echo ""
echo "=== Blue/Green Configuration ==="
echo "BLUE_GREEN_CONFIG: $BLUE_GREEN_CONFIG"

SERVICE=$(echo "$SCOPE_RULE" | jq .service)
echo ""
echo "=== Service Configuration ==="
echo "$SERVICE" | jq '.'

# Define output file
HTTPROUTE_FILE="$OUTPUT_DIR/httproute-$SERVICE_ID-$SCOPE_ID-public.yaml"

# Create output directory if it doesn't exist
mkdir -p "$OUTPUT_DIR"

# Use case 1 - empty httproute
echo ""
echo "=== Checking if HTTPRoute is empty ==="
IS_EMPTY=$(is_httproute_empty "$HTTPROUTE")
echo "Is HTTPRoute empty? $IS_EMPTY"

if [[ "$IS_EMPTY" == "true" ]]; then
  echo "Case 1: Updating empty HTTPRoute"
  UPDATED_HR=$(update_httproute_rule "$HTTPROUTE" "$RULE_PATH" "$SERVICE" "$BLUE_GREEN_CONFIG")
  echo "$UPDATED_HR" | yq "." > "$HTTPROUTE_FILE"
else
  RULE_INDEX=$(find_rule_index "$HTTPROUTE" "$RULE_PATH")
  echo "Found rule index for path '$RULE_PATH': $RULE_INDEX"

  # if there is a rule for the path we replace it
  if [[ "$RULE_INDEX" != "-1" ]]; then
    echo "Case 2: Replacing existing rule at index $RULE_INDEX"
    UPDATED_HR=$(replace_existing_rule "$HTTPROUTE" "$RULE_PATH" "$SERVICE" "$BLUE_GREEN_CONFIG" "$RULE_INDEX")
    echo "$UPDATED_HR" | yq "." > "$HTTPROUTE_FILE"
  else
    # if there is no rule for the path we add a new one
    echo "Case 3: Adding new rule"
    UPDATED_HR=$(add_new_rule "$HTTPROUTE" "$RULE_PATH" "$SERVICE" "$BLUE_GREEN_CONFIG")
    echo "$UPDATED_HR" | yq "." > "$HTTPROUTE_FILE"
  fi
fi

echo ""
echo "=== HTTPRoute configuration saved to: $HTTPROUTE_FILE ==="
