#!/bin/bash

set -euo pipefail

is_virtualservice_empty() {
  local yaml_content="$1"

  local num_http_routes
  local has_fault
  local service_host

  num_http_routes=$(yq '.spec.http | length' <<< "$yaml_content")
  has_fault=$(yq '.spec.http[0].fault.abort' <<< "$yaml_content")
  service_host=$(yq '.spec.http[0].route[0].destination.host' <<< "$yaml_content")

  # A VirtualService is "empty" if it only has one route with a 404 fault injection to response-404
  if [[ "$num_http_routes" -eq 1 && \
        "$has_fault" != "null" && \
        "$service_host" =~ response-404 ]]; then
    echo "true"
  else
    echo "false"
  fi
}

create_http_route() {
  local rule_path="$1"
  local service_json="$2"
  local blue_green_config="$3"

  local service_name
  local service_port

  service_name=$(echo "$service_json" | jq -r '.name')
  service_port=$(echo "$service_json" | jq -r '.port.number // .port.name // 80')

  # Check if there's blue/green configuration
  if [[ "$blue_green_config" != "null" && -n "$blue_green_config" ]]; then
    # Parse blue/green destinations and weights from the annotation
    local blue_weight green_weight blue_service green_service

    blue_weight=$(echo "$blue_green_config" | jq -r '.forward.targetGroups[0].weight // 100')
    green_weight=$(echo "$blue_green_config" | jq -r '.forward.targetGroups[1].weight // 0')
    blue_service=$(echo "$blue_green_config" | jq -r '.forward.targetGroups[0].serviceName')
    green_service=$(echo "$blue_green_config" | jq -r '.forward.targetGroups[1].serviceName')

    # Create route with weighted destinations
    jq -n \
      --arg path "$rule_path" \
      --arg blue_service "$blue_service" \
      --arg green_service "$green_service" \
      --arg service_port "$service_port" \
      --arg namespace "$K8S_NAMESPACE" \
      --argjson blue_weight "$blue_weight" \
      --argjson green_weight "$green_weight" \
      '{
        match: [
          {
            uri: {
              prefix: $path
            }
          }
        ],
        route: [
          {
            destination: {
              host: ($blue_service + "." + $namespace + ".svc.cluster.local"),
              port: {
                number: ($service_port | tonumber)
              }
            },
            weight: $blue_weight
          },
          {
            destination: {
              host: ($green_service + "." + $namespace + ".svc.cluster.local"),
              port: {
                number: ($service_port | tonumber)
              }
            },
            weight: $green_weight
          }
        ]
      }'
  else
    # Single destination without blue/green
    jq -n \
      --arg path "$rule_path" \
      --arg service_name "$service_name" \
      --arg service_port "$service_port" \
      --arg namespace "$K8S_NAMESPACE" \
      '{
        match: [
          {
            uri: {
              prefix: $path
            }
          }
        ],
        route: [
          {
            destination: {
              host: ($service_name + "." + $namespace + ".svc.cluster.local"),
              port: {
                number: ($service_port | tonumber)
              }
            }
          }
        ]
      }'
  fi
}

update_virtualservice_route() {
  local vs_yaml="$1"
  local rule_path="$2"
  local service_json="$3"
  local blue_green_config="$4"

  local service_name
  local service_port
  local updated_vs

  service_name=$(echo "$service_json" | jq -r '.name')
  service_port=$(echo "$service_json" | jq -r '.port.number // .port.name // 80')

  # Remove fault injection
  updated_vs=$(echo "$vs_yaml" | yq eval 'del(.spec.http[0].fault)')
  updated_vs=$(echo "$updated_vs" | yq eval ".spec.http[0].match[0].uri.prefix = \"$rule_path\"")

  # Check if there's blue/green configuration
  if [[ "$blue_green_config" != "null" && -n "$blue_green_config" ]]; then
    # Parse blue/green destinations and weights
    local blue_weight green_weight blue_service green_service

    blue_weight=$(echo "$blue_green_config" | jq -r '.forward.targetGroups[0].weight // 100')
    green_weight=$(echo "$blue_green_config" | jq -r '.forward.targetGroups[1].weight // 0')
    blue_service=$(echo "$blue_green_config" | jq -r '.forward.targetGroups[0].serviceName')
    green_service=$(echo "$blue_green_config" | jq -r '.forward.targetGroups[1].serviceName')

    # Set blue destination
    updated_vs=$(echo "$updated_vs" | yq eval ".spec.http[0].route[0].destination.host = \"${blue_service}.${K8S_NAMESPACE}.svc.cluster.local\"")
    updated_vs=$(echo "$updated_vs" | yq eval ".spec.http[0].route[0].destination.port.number = $service_port")
    updated_vs=$(echo "$updated_vs" | yq eval ".spec.http[0].route[0].weight = $blue_weight")

    # Add green destination
    updated_vs=$(echo "$updated_vs" | yq eval ".spec.http[0].route += [{\"destination\": {\"host\": \"${green_service}.${K8S_NAMESPACE}.svc.cluster.local\", \"port\": {\"number\": $service_port}}, \"weight\": $green_weight}]")
  else
    # Single destination
    updated_vs=$(echo "$updated_vs" | yq eval ".spec.http[0].route[0].destination.host = \"${service_name}.${K8S_NAMESPACE}.svc.cluster.local\"")
    updated_vs=$(echo "$updated_vs" | yq eval ".spec.http[0].route[0].destination.port.number = $service_port")
  fi

  echo "$updated_vs"
}

find_route_index() {
  local vs_yaml="$1"
  local target_path="$2"

  local num_routes
  local i
  local current_path

  num_routes=$(yq '.spec.http | length' <<< "$vs_yaml")

  for ((i=0; i<num_routes; i++)); do
    current_path=$(yq ".spec.http[$i].match[0].uri.prefix" <<< "$vs_yaml")
    if [[ "$current_path" == "\"$target_path\"" || "$current_path" == "$target_path" ]]; then
      echo "$i"
      return
    fi
  done

  echo "-1"  # Not found
}

replace_existing_route() {
  local vs_yaml="$1"
  local rule_path="$2"
  local service_json="$3"
  local blue_green_config="$4"
  local route_index="$5"

  local updated_vs
  local new_route

  # Create the new route
  new_route=$(create_http_route "$rule_path" "$service_json" "$blue_green_config")

  # Replace the existing route at the found index
  updated_vs=$(echo "$vs_yaml" | yq eval -o=json '.' | \
    jq --argjson newroute "$new_route" ".spec.http[$route_index] = \$newroute" | \
    yq eval -P '.')

  echo "$updated_vs" | yq .
}

add_new_route() {
  local vs_yaml="$1"
  local rule_path="$2"
  local service_json="$3"
  local blue_green_config="$4"

  local updated_vs
  local new_route

  # Create the new http route
  new_route=$(create_http_route "$rule_path" "$service_json" "$blue_green_config")

  # Add the new route to the existing http array
  updated_vs=$(echo "$vs_yaml" | yq eval ".spec.http += [$new_route]")

  echo "$updated_vs"
}

# Main script logic
echo "=== Starting build_ingress_with_rule for Istio ==="
echo "K8S_NAMESPACE: $K8S_NAMESPACE"
echo "SERVICE_ID: $SERVICE_ID"
echo "SCOPE_ID: $SCOPE_ID"
echo "RULE_PATH: $RULE_PATH"

VS_NAME=$(kubectl get virtualservice -n "$K8S_NAMESPACE" -l "service_id=$SERVICE_ID" -o jsonpath="{.items[0].metadata.name}")
echo "Found VirtualService: $VS_NAME"

VIRTUALSERVICE=$(kubectl get virtualservice -n "$K8S_NAMESPACE" "$VS_NAME" -o yaml)

# Extract blue/green annotation and service from SCOPE_RULE (similar to ALB version)
echo ""
echo "=== SCOPE_RULE content ==="
echo "$SCOPE_RULE" | jq '.'

BLUE_GREEN_CONFIG=$(echo "$SCOPE_RULE" | jq -r '.blue_green_annotation // "null"')
echo ""
echo "=== Blue/Green Configuration ==="
echo "BLUE_GREEN_CONFIG: $BLUE_GREEN_CONFIG"

SERVICE=$(echo "$SCOPE_RULE" | jq .service)
echo ""
echo "=== Service Configuration ==="
echo "$SERVICE" | jq '.'

# Define output file
VS_FILE="$OUTPUT_DIR/virtualservice-$SERVICE_ID-$SCOPE_ID-public.yaml"

# Create output directory if it doesn't exist
mkdir -p "$OUTPUT_DIR"

# Use case 1 - empty virtualservice
echo ""
echo "=== Checking if VirtualService is empty ==="
IS_EMPTY=$(is_virtualservice_empty "$VIRTUALSERVICE")
echo "Is VirtualService empty? $IS_EMPTY"

if [[ "$IS_EMPTY" == "true" ]]; then
  echo "Case 1: Updating empty VirtualService"
  UPDATED_VS=$(update_virtualservice_route "$VIRTUALSERVICE" "$RULE_PATH" "$SERVICE" "$BLUE_GREEN_CONFIG")
  echo "$UPDATED_VS" | yq "." > "$VS_FILE"
else
  ROUTE_INDEX=$(find_route_index "$VIRTUALSERVICE" "$RULE_PATH")
  echo "Found route index for path '$RULE_PATH': $ROUTE_INDEX"

  # if there is a route for the path we replace it
  if [[ "$ROUTE_INDEX" != "-1" ]]; then
    echo "Case 2: Replacing existing route at index $ROUTE_INDEX"
    UPDATED_VS=$(replace_existing_route "$VIRTUALSERVICE" "$RULE_PATH" "$SERVICE" "$BLUE_GREEN_CONFIG" "$ROUTE_INDEX")
    echo "$UPDATED_VS" | yq "." > "$VS_FILE"
  else
    # if there is no route for the path we add a new one
    echo "Case 3: Adding new route"
    UPDATED_VS=$(add_new_route "$VIRTUALSERVICE" "$RULE_PATH" "$SERVICE" "$BLUE_GREEN_CONFIG")
    echo "$UPDATED_VS" | yq "." > "$VS_FILE"
  fi
fi

echo ""
echo "=== VirtualService configuration saved to: $VS_FILE ==="