#!/bin/bash

ENVIRONMENT=$(echo "$CONTEXT" | jq -r .scope.dimensions.environment)

# Check parameters (handle null results safely)
HAS_APP_NAME=$(echo "$CONTEXT" | jq -r '(.parameters.results // [])[] | select(.name == "APP_NAME") | .values[0].value // "not_set"' | head -n 1)
HAS_APP_NAME=${HAS_APP_NAME:-not_set}
HAS_ROLE=$(echo "$CONTEXT" | jq -r '(.parameters.results // [])[] | select(.name == "AWS_ROLE_ARN") | .values[0].value // "not_set"' | head -n 1)
HAS_ROLE=${HAS_ROLE:-not_set}

CONFIGMAP_NAME="fluent-bit-config"
CONFIGMAP_NAMESPACE="default"

SERVICE_ACCOUNT_NAME=$(echo "$CONTEXT" | jq -r .service_account_name)
echo "Looking for IAM role: $SERVICE_ACCOUNT_NAME"

ROLE_ARN=$(aws iam get-role --role-name "$SERVICE_ACCOUNT_NAME" --query 'Role.Arn' --output text 2>&1) || {
  echo "ERROR: Failed to find IAM role '$SERVICE_ACCOUNT_NAME'"
  echo "AWS Error: $ROLE_ARN"
  echo "Make sure the role exists and you have IAM permissions"
  exit 1
}

echo "Checking CloudWatch Logs requirements..."

if [[ "$HAS_APP_NAME" != "not_set" && 
      # "$ENVIRONMENT" == "prd" && 
      "$CLUSTER_NAME" == "spin-cluster-prod" ]]; then
    echo "Setting app Cloudwatch logs... Looking for config map $CONFIGMAP_NAME in namespace $CONFIGMAP_NAMESPACE"

    # Check ConfigMap existence
    if ! kubectl get configmap "$CONFIGMAP_NAME" -n "$CONFIGMAP_NAMESPACE" > /dev/null 2>&1; then
        echo "Error: Required ConfigMap '$CONFIGMAP_NAME' was not found in namespace '$CONFIGMAP_NAMESPACE'. CloudWatch logs configuration cannot proceed."
        exit 1
    fi
    echo "ConfigMap '$CONFIGMAP_NAME' found."

    # Calculate Datadog environment variables
    DD_ENV="$ENVIRONMENT"
    DD_VERSION=$(echo "$CONTEXT" | jq -r .release.semver)
    DD_SERVICE=$(basename "$(echo "$CONTEXT" | jq -r '.application.repository_url')-kubernetes" | cut -c1-63)
    DD_INTERNAL_POD_UID="\$(DD_INTERNAL_POD_UID)"

    echo "Adding fluent-bit container to deployments..."
    echo "DD_SERVICE: $DD_SERVICE"
    echo "DD_VERSION: $DD_VERSION"
    echo "DD_ENV: $DD_ENV"
    echo "APP_NAME: $HAS_APP_NAME"
    echo "AWS_ROLE_ARN: $ROLE_ARN"

    # Add fluent-bit container to each deployment file
    for deployment_file in "$OUTPUT_DIR"/deployment-*.yaml; do
        if [ -f "$deployment_file" ]; then
            kind=$(yq eval '.kind' "$deployment_file")
            echo "Adding fluent-bit container to: $deployment_file of kind $kind"

            # Define the fluent-bit container spec
            FLUENT_BIT_CONTAINER=$(cat <<EOF
{
  "name": "fluent-bit",
  "image": "public.ecr.aws/aws-observability/aws-for-fluent-bit:stable",
  "imagePullPolicy": "Always",
  "env": [
    {"name": "DD_ENV", "value": "$DD_ENV"},
    {"name": "DD_VERSION", "value": "$DD_VERSION"},
    {"name": "DD_SERVICE", "value": "$DD_SERVICE"},
    {"name": "DD_EXTERNAL_ENV", "value": "it-false,cn-fluent-bit,pu-\$(DD_INTERNAL_POD_UID)"},
    {"name": "APP_NAME", "value": "$HAS_APP_NAME"},
    {"name": "AWS_STS_REGIONAL_ENDPOINTS", "value": "regional"},
    {"name": "DD_INTERNAL_POD_UID", "valueFrom": {"fieldRef": {"fieldPath": "metadata.uid"}}}
  ],
  "resources": {
    "limits": {"cpu": "200m", "memory": "200Mi"},
    "requests": {"cpu": "100m", "memory": "100Mi"}
  },
  "terminationMessagePath": "/dev/termination-log",
  "terminationMessagePolicy": "File",
  "volumeMounts": [
    {"mountPath": "/var/log", "name": "varlog", "readOnly": true},
    {"mountPath": "/fluent-bit/etc/", "name": "fluent-bit-config"}
  ]
}
EOF
)

            if [ "$kind" = "CronJob" ]; then
                # Add fluent-bit container to CronJob
                yq eval -i ".spec.jobTemplate.spec.template.spec.containers += [$FLUENT_BIT_CONTAINER]" "$deployment_file"
                
                # Add volumes if they don't exist
                yq eval -i '.spec.jobTemplate.spec.template.spec.volumes += [{"name": "varlog", "emptyDir": {}}]' "$deployment_file"
                yq eval -i '.spec.jobTemplate.spec.template.spec.volumes += [{"name": "fluent-bit-config", "configMap": {"name": "'"$CONFIGMAP_NAME"'"}}]' "$deployment_file"
            else
                # Add fluent-bit container to Deployment/others
                yq eval -i ".spec.template.spec.containers += [$FLUENT_BIT_CONTAINER]" "$deployment_file"
                
                # Add volumes if they don't exist
                yq eval -i '.spec.template.spec.volumes += [{"name": "varlog", "emptyDir": {}}]' "$deployment_file"
                yq eval -i '.spec.template.spec.volumes += [{"name": "fluent-bit-config", "configMap": {"name": "'"$CONFIGMAP_NAME"'"}}]' "$deployment_file"
            fi
            
            echo "Successfully added fluent-bit container to $deployment_file"
        fi
    done

    # Now add ConfigMap reference and AWS_ROLE_ARN to all containers
    for deployment_file in "$OUTPUT_DIR"/deployment-*.yaml; do
        if [ -f "$deployment_file" ]; then
            kind=$(yq eval '.kind' "$deployment_file")
            echo "Processing: $deployment_file of kind $kind"

            if [ "$kind" = "CronJob" ]; then
                # Add envFrom to fluent-bit container in CronJob
                yq eval -i ".spec.jobTemplate.spec.template.spec.containers[].envFrom += [{\"configMapRef\": {\"name\": \"$CONFIGMAP_NAME\"}}]" "$deployment_file"
                # Add AWS_ROLE_ARN environment variable
                yq eval -i ".spec.jobTemplate.spec.template.spec.containers[].env += [{\"name\": \"AWS_ROLE_ARN\", \"value\": \"$ROLE_ARN\"}]" "$deployment_file"
            else
                # Add envFrom to fluent-bit container in Deployment/others
                yq eval -i ".spec.template.spec.containers[].envFrom += [{\"configMapRef\": {\"name\": \"$CONFIGMAP_NAME\"}}]" "$deployment_file"
                # Add AWS_ROLE_ARN environment variable
                yq eval -i ".spec.template.spec.containers[].env += [{\"name\": \"AWS_ROLE_ARN\", \"value\": \"$ROLE_ARN\"}]" "$deployment_file"
            fi
            
            echo "Successfully configured cloudwatch logs for $deployment_file"
        fi
    done
else
    echo "Skipping cloudwatch logs configuration for Environment=$ENVIRONMENT, Cluster=$CLUSTER_NAME. Parameters present: APP_NAME=$HAS_APP_NAME, SERVICE_NAME=$HAS_SERVICE_NAME, AWS_ROLE_ARN=$HAS_ROLE"
fi
