#!/bin/bash

ALB_NAME=$(echo "$CONTEXT" | jq -r .alb_name)
EXPOSER_DOMAIN=$(echo "$CONTEXT" | jq -r '.parameters.domain // .service.attributes.domain')

SERVICE_ID=$(echo "$CONTEXT" | jq -r .service.id)
SERVICE_SLUG=$(echo "$CONTEXT" | jq -r .service.slug)
EXPECTED_RULES=$(echo "$CONTEXT" | jq '((.service.attributes.rules // []) + (.parameters.rules // [])) | unique')

INGRESS_NAME="k-8-s-$SERVICE_SLUG-$SERVICE_ID-public"
MAX_WAIT_SECONDS=120
CHECK_INTERVAL=10
elapsed=0


echo "Waiting for ingress [$INGRESS_NAME] reconciliation..."

ALB_RECONCILIATION_ENABLED="${ALB_RECONCILIATION_ENABLED:-false}"

if [ "$ALB_RECONCILIATION_ENABLED" = "false" ] && [ "$IS_SERVICE_CREATION" = "false" ]; then
    echo "⚠ Skipping verification as ALB access needed to validate blue-green and switch traffic reconciliation."

    return 0
fi

if [ "$ALB_RECONCILIATION_ENABLED" = "true" ]; then
    echo "Validating ALB [$ALB_NAME] configuration for domain [$EXPOSER_DOMAIN]"
else
    echo "ALB reconciliation disabled, will check cluster events only"
fi

INGRESS_JSON=$(kubectl get ingress "$INGRESS_NAME" -n "$K8S_NAMESPACE" -o json 2>/dev/null)

if [ $? -ne 0 ]; then
    echo "✗ Failed to get ingress $INGRESS_NAME"
    exit 1
fi

current_resource_version=$(echo "$INGRESS_JSON" | jq -r '.metadata.resourceVersion')

if [ "$ALB_RECONCILIATION_ENABLED" = "true" ]; then
    ALB_ARN=$(aws elbv2 describe-load-balancers \
            --names "$ALB_NAME" \
            --region "$REGION" \
            --query 'LoadBalancers[0].LoadBalancerArn' \
            --output text 2>&1)

    if [ $? -ne 0 ] || [ "$ALB_ARN" == "None" ] || [ -z "$ALB_ARN" ]; then
        echo "⚠ Could not find ALB: $ALB_NAME"
        return 1
    fi
fi

validate_alb_config() {
    LISTENERS=$(aws elbv2 describe-listeners \
        --load-balancer-arn "$ALB_ARN" \
        --region "$AWS_REGION" \
        --output json 2>&1)

    if [ $? -ne 0 ]; then
        echo "⚠ Could not get listeners for ALB"
        return 1
    fi

    echo "Checking domain: $EXPOSER_DOMAIN"

    LISTENER_ARNS=$(echo "$LISTENERS" | jq -r '.Listeners[].ListenerArn')

    ALL_ALB_RULES=""
    for listener_arn in $LISTENER_ARNS; do
        RULES=$(aws elbv2 describe-rules \
            --listener-arn "$listener_arn" \
            --region "$AWS_REGION" \
            --output json 2>&1)

        if [ $? -ne 0 ]; then
            continue
        fi

        ALL_ALB_RULES="${ALL_ALB_RULES}$(echo "$RULES" | jq -c '.Rules[]')"
    done

    if [ -z "$ALL_ALB_RULES" ]; then
        echo "  ✗ No ALB rules found"
        return 1
    fi

    DOMAIN_RULE=$(echo "$ALL_ALB_RULES" | jq -s --arg domain "$EXPOSER_DOMAIN" '
        .[] | select(
            .Conditions[]? | select(.Field == "host-header") | .Values[]? == $domain
        )
    ' 2>/dev/null)

    if [ -z "$DOMAIN_RULE" ]; then
        echo "  ✗ Domain not found in ALB rules: $EXPOSER_DOMAIN"
        return 1
    fi

    echo "  ✓ Found rule for domain: $EXPOSER_DOMAIN"

    EXPECTED_PATHS=$(echo "$EXPECTED_RULES" | jq -r '.[].path // empty' 2>/dev/null)
    PARAMETER_PATH=$(echo "$CONTEXT" | jq -r '.parameters.path // empty')
    if [ -n "$PARAMETER_PATH" ]; then
        EXPECTED_PATHS=$(printf "%s\n%s" "$EXPECTED_PATHS" "$PARAMETER_PATH" | sort -u)
    fi

    if [ -z "$EXPECTED_PATHS" ]; then
        echo "✓ Domain rule is configured in ALB"
        return 0
    fi

    all_rules_found=true

    for expected_path in $EXPECTED_PATHS; do
        MATCHING_RULE=$(echo "$ALL_ALB_RULES" | jq -s --arg domain "$EXPOSER_DOMAIN" --arg path "$expected_path" '
            .[] | select(
                (.Conditions[]? | select(.Field == "host-header") | .Values[]? == $domain) and
                (.Conditions[]? | select(.Field == "path-pattern") | .Values[]? | startswith($path))
            )
        ' 2>/dev/null)

        if [ -n "$MATCHING_RULE" ]; then
            echo "  ✓ Found rule for path: $expected_path"
        else
            echo "  ✗ Missing rule for path: $expected_path"
            all_rules_found=false
        fi
    done

    if [ "$all_rules_found" = true ]; then
        echo "✓ All expected rules are configured in ALB"
        return 0
    else
        echo "⚠ Some rules are missing from ALB configuration"
        return 1
    fi
}

while [ $elapsed -lt $MAX_WAIT_SECONDS ]; do
    if [ "$ALB_RECONCILIATION_ENABLED" = "true" ]; then
        if validate_alb_config; then
            echo "✓ ALB configuration validated successfully"
            return 0
        fi

        echo "ALB validation incomplete, checking Kubernetes events..."
    fi

    events_json=$(kubectl get events -n "$K8S_NAMESPACE" \
        --field-selector "involvedObject.name=$INGRESS_NAME,involvedObject.kind=Ingress" \
        -o json)

    relevant_events=$(echo "$events_json" | jq --arg rv "$current_resource_version" '
          .items | map(select((.involvedObject.resourceVersion | tonumber) >= ($rv | tonumber)))
      ')

    event_count=$(echo "$relevant_events" | jq 'length')

    if [ "$event_count" -gt 0 ]; then
        newest_event=$(echo "$relevant_events" | jq -r 'sort_by(.lastTimestamp) | last')
        event_type=$(echo "$newest_event" | jq -r '.type')
        event_reason=$(echo "$newest_event" | jq -r '.reason')
        event_message=$(echo "$newest_event" | jq -r '.message')

        if [ "$event_reason" == "SuccessfullyReconciled" ]; then
            echo "✓ Ingress was successfully reconciled (via event)"
            return 0
        fi

        if echo "$event_message" | grep -q "no certificate found for host"; then
            echo "✗ Certificate error detected"
            echo "Root cause: The ingress hostname does not match any available SSL/TLS certificate"
            echo "Message: $event_message"

            echo "To fix this issue:"
            echo "  1. Verify the hostname in your ingress matches a certificate in ACM (AWS Certificate Manager)"
            echo "  2. Check the 'alb.ingress.kubernetes.io/certificate-arn' annotation points to a valid certificate"
            echo "  3. Ensure the certificate includes the exact hostname or a wildcard that covers it"
            exit 1
        fi

        if [ "$event_type" == "Error" ]; then
            echo "✗ The ingress could not be reconciled"
            echo "Error messages:"
            echo "$relevant_events" | jq -r '.[] | "  - \(.message)"'
            exit 1
        fi

        if [ "$event_type" == "Warning" ]; then
            echo "⚠ There are some potential issues with the ingress"
            echo "Warning messages:"
            echo "$relevant_events" | jq -r '.[] | "  - \(.message)"'
        fi
    fi

    echo "Waiting for ALB reconciliation... (${elapsed}s/${MAX_WAIT_SECONDS}s)"
    sleep $CHECK_INTERVAL
    elapsed=$((elapsed + CHECK_INTERVAL))
done

# Timeout reached - show diagnostic information
echo "✗ Timeout waiting for ingress reconciliation after ${MAX_WAIT_SECONDS} seconds"
echo ""
echo "Diagnostic information:"
echo "1. Check ALB Ingress Controller logs:"
echo "   kubectl logs -n kube-system -l app.kubernetes.io/name=aws-load-balancer-controller"
echo ""
echo "2. Check ingress status:"
echo "   kubectl describe ingress $INGRESS_NAME -n $K8S_NAMESPACE"
echo ""
echo "3. Recent events:"
events_json=$(kubectl get events -n "$K8S_NAMESPACE" \
    --field-selector "involvedObject.name=$INGRESS_NAME,involvedObject.kind=Ingress" \
    -o json)
echo "$events_json" | jq -r '.items | sort_by(.lastTimestamp) | .[] | "  [\(.type)] \(.reason): \(.message)"' | tail -10

exit 1